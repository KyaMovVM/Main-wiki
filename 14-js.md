# JS

``` js
let  total = 0 , count = 1 ;
 while (count <= 10 ) {
  общее количество += количество;
  count += 1 ;
}
console.log(total);


// → 55
```

В этой версии внесено еще несколько улучшений. Самое важное — больше нет необходимости указывать, как именно программа должна переключаться между блоками — конструкция whileделает это автоматически. Она продолжает выполнение блока (заключенного в фигурные скобки) до тех пор, пока выполняется заданное условие. Это условие — count <= 10, что означает «счетчик меньше или равен 10». Нам больше не нужно создавать временное значение и сравнивать его с нулем, что было просто неинтересной деталью. Одна из сильных сторон языков программирования заключается в том, что они могут сами позаботиться о неинтересных деталях.

rangeи sum, которые соответственно создают набор чисел в заданном диапазоне и вычисляют сумму набора чисел:

``` js
console.log(sum(range( 1 , 10 )));
 // → 55

```

``` js
function  factorial ( n ) {
   if (n == 0 ) {
     return  1 ;
  } else {
     return factorial(n - 1 ) * n;
  }
}

console.log(factorial(8));
```

В оставшейся части этой главы рассматриваются атомарные элементы программ на JavaScript, то есть простые типы значений и операторы, которые могут воздействовать на такие значения.

Декомпозиция?

Числа

В JavaScript для хранения одного числового значения используется фиксированное количество битов — 64. С помощью 64 бит можно создать лишь ограниченное количество шаблонов, что ограничивает число различных чисел, которые можно представить. С помощью N десятичных знаков можно представить 10⁹ чисел . Аналогично, имея 64 двоичных знака, можно представить 2⁶⁴ различных чисел, что составляет примерно 18 квинтиллионов (18 с 18 нулями после него). Это очень много.

Вычисления с целыми числами (также называемыми целыми числами ), меньшими, чем упомянутые выше 9 квадриллионов, гарантированно всегда будут точными. К сожалению, вычисления с дробными числами, как правило, не являются точными. Точно так же, как π (пи) не может быть точно выражено конечным числом десятичных знаков, многие числа теряют некоторую точность, когда для их хранения доступно только 64 бита. Это досадно, но на практике это создает проблемы только в определенных ситуациях. Важно помнить об этом и рассматривать дробные числа как приближения, а не как точные значения.

Арифметика

Основное, что делается с числами, — это арифметика. Арифметические операции, такие как сложение или умножение, берут два числовых значения и выдают из них новое число. Вот как они выглядят в JavaScript:

100 + 4 * 11
Символы « +и» *называются операторами.

Существует ещё один арифметический оператор, который вы, возможно, не сразу узнаете. Символ % используется для обозначения операции с остатком . X % Y— это остаток от деления Xна Y. Например, 314 % 100даёт 14, а . Приоритет оператора с остатком такой же, как у умножения и 144 % 12деления 0. Вы также часто будете встречать этот оператор как по модулю .

Специальные номера

Первые два — это Infinityи -Infinity, которые представляют положительную и отрицательную бесконечность. Infinity - 1по-прежнему равно Infinity, и так далее. Однако не стоит слишком доверять вычислениям, основанным на бесконечности. Это математически некорректно и быстро приведет к следующему специальному числу: NaN.

Строки

Следующий базовый тип данных — строка . Строки используются для представления текста. Их содержимое заключается в кавычки.

«Вниз по морю» 
«Лежать на океане» 
«Плыть по океану»
Для обозначения строк можно использовать одинарные, двойные или обратные кавычки, при условии, что кавычки в начале и в конце строки совпадают

Однако есть одна сложность: в JavaScript для каждого строкового элемента используется 16 бит, что позволяет описать до 2 ¹⁶ различных символов. В то же время, Unicode определяет больше символов — примерно вдвое больше. Поэтому некоторые символы, например, многие эмодзи, занимают две «позиции» в строках JavaScript. Мы вернемся к этому в главе 5 .

Строки нельзя делить, умножать или вычитать. +Оператор `\` можно использовать не для сложения, а для конкатенации — для склеивания двух строк. Следующая строка даст строку "concatenate":

"con" + "cat" + "e" + "nate"

Строковые значения имеют ряд связанных с ними функций ( методов )

Строки, написанные в одинарных или двойных кавычках, ведут себя практически одинаково — разница лишь в типе кавычек, которые нужно экранировать внутри них. Строки в обратных кавычках, обычно называемые шаблонными литералами , могут выполнять несколько дополнительных функций. Помимо возможности переноса на несколько строк, они также могут встраивать другие значения.

Строки в обратных кавычках, обычно называемые шаблонными литералами , могут выполнять несколько дополнительных функций. Помимо возможности переноса на несколько строк, они также могут встраивать другие значения.

«Половина от 100 — это ${ 100 / 2 } »

Когда вы записываете что-либо внутри ${}шаблонного литерала, его результат вычисляется, преобразуется в строку и включается в указанную позицию. В этом примере получается строка "half of 100 is 50".

Унарные операторы

Не все операторы являются символами. Некоторые записываются словами. Например, typeofоператор `\n`, который возвращает строковое значение, указывающее тип передаваемого ему значения.

console.log( typeof  4.5 )

Операторы, использующие два значения, называются бинарными операторами, а те, которые принимают одно значение, — унарными операторами. Оператор минус ( -) может использоваться как бинарный, так и унарный оператор.

console.log(- ( 10 - 2 ))
 // → -8

Логические значения

console.log( 3 > 2 )

console.log( "Aardvark" < "Zoroaster" )

Порядок строк приблизительно алфавитный, но не совсем такой, каким вы ожидаете его увидеть в словаре: заглавные буквы всегда «меньше», чем строчные, поэтому "Z" < "a", а неалфавитные символы (!, -, и так далее) также включаются в порядок. При сравнении строк JavaScript проходит по символам слева направо, сравнивая коды Unicode один за другим.

console.log( "Гранат" != "Рубин" )
 // → true 
console.log( "Жемчуг" == "Аметист" )
 // → false

 В JavaScript существует только одно значение, которое не равно самому себе, и это NaN(«не число»).

console.log(NaN == NaN)
 // → false

Логические операторы

console.log(true && false)
 // → false
console.log(true && true)
// → true

console.log(false || true)
 // → true
console.log(false || false)
// → false

!true в результате получается false и !false выдается true.

Тернарный оператор , работающий с тремя значениями. Он записывается с вопросительным знаком и двоеточием, вот так:

console.log(true ? 1 : 2 );
 // → 1 
console.log(false ? 1 : 2 );
 // → 2

 Этот оператор называется условным оператором (или иногда просто тернарным оператором, поскольку это единственный такой оператор в языке). Оператор использует значение слева от вопросительного знака, чтобы определить, какое из двух других значений «выбрать». Если вы напишете a ? b : c, результатом будет , bкогда aистинно, и , cв противном случае.

Пустые значения

null и undefined

Замыкание логических операторов

Логические операторы &&обрабатывают ||значения разных типов особым образом. Они преобразуют значение слева от себя в логический тип (Boolean), чтобы определить дальнейшие действия, но в зависимости от оператора и результата этого преобразования они возвращают либо исходное значение слева, либо значение справа.

console.log( null || "user" )
 // → user 
console.log( "Agnes" || "user" )
 // → Agnes

 Правила преобразования строк и чисел в логические значения гласят, что 0, NaN, и пустая строка ( "") считаются false, в то время как все остальные значения считаются true.

 That means 0 || -1 produces -1, and "" || "!?" yields "!?".

 Оператор ??похож на другой ||, но возвращает значение справа только в том случае, если значение слева равно null или undefined, а не если это какое-либо другое значение, которое можно преобразовать в false. Часто это предпочтительнее поведения оператора ||.

console.log( 0 || 100 );
 // → 100 
console.log( 0 ?? 100 );
 // → 0 
console.log( null ?? 100 );
 // → 100

 Ещё одно важное свойство этих двух операторов заключается в том, что часть справа от них вычисляется только тогда, когда это необходимо. В случае true || X, независимо от того, что Xявляется — даже если это фрагмент программы, который делает что-то ужасное — результат будет истинным и Xникогда не вычисляется. То же самое относится к false && X, который является ложным и игнорирует X. Это называется кратчайшим вычислением .

Краткое содержание

Мы рассмотрели бинарные операторы для арифметических операций ( +, -, *, /, и %), конкатенацию строк ( +), сравнение ( ==, !=, ===, !==, <, >, <=, >=) и логические операции ( &&, ||, ??), а также несколько унарных операторов ( -для инвертирования числа, !для логического инвертирования и typeofдля определения типа значения) и тернарный оператор ( ?:) для выбора одного из двух значений на основе третьего значения.

## Bindings

let caught = 5 * 5;

let  mood = "light" ; 
console.log(mood); // → light 
mood = "dark" ; 
console.log(mood); // → dark

const  greeting = "Hello" ; 

Имена привязки

Имя привязки может включать знаки доллара ( $) или подчеркивания ( _), но не другие знаки препинания или специальные символы.

Слова, имеющие особое значение, например let, `<br>`, являются ключевыми словами и не могут использоваться в качестве имен привязки. Существует также ряд слов, «зарезервированных для использования» в будущих версиях JavaScript, которые также не могут использоваться в качестве имен привязки. Полный список ключевых слов и зарезервированных слов довольно длинный:

break case catch class const continue debugger default 
delete do else enum export extends false finally for 
function if implements import interface in instanceof let 
new package private protected public return static super 
switch this throw true try typeof var void while with yield

Функции

Многие значения, предоставляемые в среде по умолчанию, имеют тип «функция» . Функция — это фрагмент программы, обернутый в значение. Такие значения можно использовать для запуска обернутой программы. Например, в браузерной среде привязка promptсодержит функцию, которая отображает небольшое диалоговое окно с запросом ввода данных от пользователя. Она используется следующим образом:

prompt("Enter passcode");